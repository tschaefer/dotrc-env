#!/bin/bash

###################################
##	global variables
###################################
ME=${0##*/}
VERSION="$Version$"
DATE="$Date$"

###################################
##	return codes
###################################
OK=0
UERROR=1
ERROR=2

###################################
##	print help
usage() {
###################################
cat <<EOF

NAME:
	$ME - installs and initialize dotrc-env

SYNOPSIS
	$ME -h|-v
	$ME [-D] file://URI|http[s]://URI|rsync://URI|scp://URI

DESCRIPTION
		$ME creates local directories, fetches, decrypts (openssl), unpacks private
		data (gnupg keys, ssh keys, ovpn keys) and finally links dotrc files in user
		home.

		-D:		debug information
		-h:		show this message (help)
		-v:		show version

RETURNCODES
	$OK - ok
	$UERROR - usage error
	$ERROR - run error

EXAMPLES
	$ME -v
		* prints version and exits.
	$ME scp://user@host:/path/to/my-private-data.tar.gz.nc
		* gets private data via scp from host as user.

AUTHOR
	Written by Tobias Schaefer <Tobias.Schaefer at tt.blackox.org>

COPYRIGHT
	Copyright (c) 2010 Tobias Schaefer.
	License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
	This is free software: you are free to change and redistribute it.
	There is NO WARRANTY, to the extent permitted by law.

REPORT BUGS
	Report bugs to <bug-template at tt.blackox.org>

EOF
}

###################################
##	print version, date and author
version() {
###################################
cat <<EOF

	$ME $VERSION $DATE

	Written by Tobias Schaefer <Tobias.Schaefer at tt.blackox.org>

EOF
}

###################################
##	print error
_perror() {
###################################
	echo "$ME: ERROR: $1" >&2
	exit "$ERROR"
}

###################################
##	print warning
_pwarn() {
###################################
	echo "$ME: WARNING: $1" >&2
}

###################################
##	print usage error
_uerror() {
###################################
	echo "$ME: USAGE: $1" >&2
	exit "$UERROR"
}

###################################
##	get options
get_opts() {
###################################
	opt_D=""; opt_h=""; opt_v="";
	opt_count=0

	while getopts ":Dhv" opt; do
		case "$opt" in
			D)
				opt_D=1
				(( opt_count++ ))
				;;
			h)
				opt_h=1
				(( opt_count++ ))
				;;
			v)
				opt_v=1
				(( opt_count++ ))
				;;
			*)
				#case "$OPTARG" in
				#	a|b|c)
				#		_uerror "-$OPTARG missing argument"
				#		;;
				#esac
				_uerror "unknown option -$OPTARG"
				exit 1
				;;
		esac
	done
}

###################################
##	check options / arguments
check_usage() {
###################################
	# get help xor version
	[ -n "$opt_h" -o -n "$opt_v" ] && [ "$opt_count" -ne 1 ] && {
		_uerror "use -h/-v only seperate"
	}

	# print help xor version
	[ -n "$opt_h" ] && {
		usage
		exit "$OK"
	}
	[ -n "$opt_v" ] && {
		version
		exit "$OK"
	}

	# argument, protocol and uri
	[ -z "${1}" ] && {
		_uerror "missing argument"
	}

	PROTOCOL=${1%%://*}
	URI=${1#*://}
	DATA=${1##*/}

	[ ${1} != ${PROTOCOL}://${URI} ] && {
		_uerror "bad argument"
	}

}

###################################
##	check required environment
check_env() {
###################################
	# openssl
	type -P openssl >/dev/null 2>&1
	[ $? -ne 0 ] && {
		_perror "openssl not found"
	}
	# ln
	type -P ln >/dev/null 2>&1
	[ $? -ne 0 ] && {
		_perror "ln not found"
	}
	# mkdir
	type -P mkdir >/dev/null 2>&1
	[ $? -ne 0 ] && {
		_perror "mkdir not found"
	}
	# touch
	type -P touch >/dev/null 2>&1
	[ $? -ne 0 ] && {
		_perror "touch not found"
	}

}

###################################
##	check_protocol
check_proto_uri() {
###################################
	# verify protocol
	case ${PROTOCOL} in
		file)
			type -P cp >/dev/null 2>&1
			[ $? -ne 0 ] && {
				_perror "cp not found"
			}
			COPYTOOL="cp"
			;;
		http|https)
			type -P wget >/dev/null 2>&1
			[ $? -ne 0 ] && {
				_perror "wget not found"
			}
			COPYTOOL="wget --no-check-certificate"
			;;
		rsync)
			type -P rsync >/dev/null 2>&1
			[ $? -ne 0 ] && {
				_perror "rsync not found"
			}
			COPYTOOL="rsync --archive"
			;;
		scp)
			type -P scp >/dev/null 2>&1
			[ $? -ne 0 ] && {
				_perror "scp not found"
			}
			COPYTOOL="scp"
			;;
		*)
			_uerror "unknown PROTOCOL"
			;;
	esac

	# verify uri
	[ -z ${URI} ] && {
		_uerror "no URI given"
	}

}

###################################
##	action
action() {
###################################
	# check and verify protocol and uri
	check_proto_uri

	# get environment etc directory
	ENV_ETC=$(cd ${0%/*} && echo ${PWD%/*}/etc)

	# link dotrc files
	for FILE in bash_logout bashrc gitconfig gnupg inputrc nanorc openvpn profile screenrc ssh subversion vim vimrc; do
		ln -si ${ENV_ETC}/${FILE} ${HOME}/.${FILE}
	done

	# create local files
	mkdir -p ${ENV_ETC}/local/vim/{backup,session,swap}
	mkdir -p ${ENV_ETC}/local/subversion/auth
	mkdir -p ${ENV_ETC}/local/ssh
	touch ${ENV_ETC}/local/ssh/known_hosts

	# copy, encrypt, unpack private files
	$COPYTOOL $URI ${ENV_ETC}
	openssl enc -d -aes-256-cbc -in ${ENV_ETC}/${DATA} -out ${ENV_ETC}/${DATA%.*}
	tar xzf ${ENV_ETC}/${DATA%.*} -C ${ENV_ETC}
	rm ${ENV_ETC}/${DATA} ${ENV_ETC}/${DATA%.*}

	# create .gitignore
	echo -e 'local/\nprivate/' > ${ENV_ETC}/.gitignore

}

###################################
##	control script
main() {
###################################
	# get options
	get_opts ${1+"$@"}
	shift $(( OPTIND - 1 ))

	# check user action
	check_usage ${1+"$@"}

	# debug
	[ -n "$opt_D" ] && {
		set -x
	}

	# check env
	check_env

	# do the action
	action

	exit "$OK"
}
main ${1+"$@"}

# vim: set ft=sh ts=4 sw=4 :
